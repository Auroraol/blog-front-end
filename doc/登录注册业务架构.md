# 登录流程

**单点登录**：就是指在多个服务中，用户只需要登录，一次就可以访问所有相互信任的服务，用户只需要退出登录一次，就可以退出所有的服务

**多端登录**：当用户登录之后，如果再换一个设备进行登录的话，可以设计将原来的那个设备上的账号踢掉线，或者两个设备上的账号同时登录，一同操作同一个用户的数据、业务等信息

## 实现方案一：JWT

使用JWT的方式，将用户的信息存储到token中，用户只需要在登录服务器登录一次，就可以生成一个token，将用户的相关信息存储到token中，然后将token存储到cookie中，之后再去访问其它相互信任的服务时，就可以直接拿token去访问，那个服务就会解析token，拿到用户信息，进而进行其它操作。

> JWT的结构：头部、载荷、签证

![image-20240305174245152](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174245152.png)

优点

- 去中心化
- 高并发

缺点

- 其它用户踢掉线无法实现

## 实现方案二：基于Redis缓存

使用Redis作为第三方存储，用户登录生成token后，将用户信息存储到Redis中(一般设置15-20过期), 而不是存储到token中了（这个token可以不基于JWT实现，只是普通的伪token即可，因为不存储信息），这样，下次浏览器再去访问其它服务器的时候，就可以使用token去Redis中获取用户信息，拿到用户信息后进行业务操作，然后返回响应数据。

在应用中,redis可以实现登录过期的功能,比如在用户提交登录时,通过设置一个过期时间,当用户30分钟内没有访问,redis就会自动将该用户的登录数据删除,从而释放宝贵的用户资源。

![image-20240305174352437](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174352437.png)

缺点

- 不是去中心化的，所有节点处理请求都依赖Redis，增加Redis负载
- 如何想要实现踢掉线的功能呢？只需将Redis中的用户信息删除即可，但是Redis中的用户信息存储的key是token，那么在其它浏览器中是拿不到这个token的，这样该如何才能去Redis中删除用户信息？

## 实现方案三：JWT+Redis缓存

使用Redis作为第三方存储，将userId存储到token中，用户登录生成token后，将用户信息存储到Redis中，key为userId，值为用户信息，下次访问其它服务器的时候，浏览器就会拿token去访问，然后服务器解析token，获取到userId，再根据userId去Redis中获取到用户信息，然后进行操作。

当想要进行踢其它用户掉线的时候，那么就需要在后台操作，后台可以直接获取到userId，然后拿userId去访问后台服务器，再拿userId去Redis中删除此用户信息，那么这个用户再访问的时候，就在Redis拿不到用户信息了，所以也就掉线了，需要重新登录。

> 踢掉线：假如你在打游戏，你发表了不良言论，我是管理员，我就要将你强制下线，这就是踢你掉线

![image-20240305174918690](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174918690.png)

缺点

- 不是去中心化的，所有节点处理请求都依赖Redis，增加Redis负载

## 实现方案四：CAS

CAS：集中式认证服务（Central Authentication Service）

> 使用Redis实现踢人掉线的功能，实际上就是使用了一个中心化的东西，而这个东西不止可以使Redis，还可以是一个服务。

浏览器去访问登录服务器，登录服务器返回一个token，登录成功。

如果浏览器没有携带token去访问业务服务器，那么请求到业务服务器之后，业务服务器再去请求登录服务器，登录服务器发现没有token，所以将此重定向到登录服务器，也就是让我们先去登录。

如果浏览器携带token去访问业务服务器，那么请求到业务服务器之后，业务服务器再去请求登录服务器，登录服务器发现token验证正确，返回给业务服务器一个此用户已登录，可以访问的消息，业务服务器收到消息之后，就可以继续执行接下来的业务了，最终执行完返回给浏览器一个响应数据，完成一次完整的请求。

![image-20240305174835381](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174835381.png)

- 可以处理踢掉线。
- 现成的代码直接可以用

缺点

- 每次验证是否登录，都需要访问登录服务器，增大了网络开销
- 增加了登陆中心的负载问题
- 当用户无权限的时候，重定向还会有问题



# jwt单点登陆和cas单点登陆有什么区别

## **CAS - Central Authentication Server**

CAS 全称 Central Authentication Server，也称作中央认证服务，是支持 JWT 的。

其分为两个部分：CAS 服务端（CAS Server） 和 CAS 客户端（CAS Client）。服务端负责认证工作，独立部署；客户端负责处理访问请求，需要登录时，重定向到服务端。

### **认证流程**

1. 浏览器向客户端请求提供某个受保护的资源。
2. 重定向到服务端进行认证
3. 用户进行身份认证
4. 服务端生成票据
5. 客户端向服务端验证票据
6. 验证成功返回用户信息

![img](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/d067e412-0eaa-48fd-8477-306e615f35e8.jpg)

## **JWT - JSON Web Token**

JWT 是一种用于在两方之间安全地表示声明的方法，是 token 思想的一种实现方式。

### **组成部分**

本质上就是一个字符串，但是其带有签名信息，接收后可以校验是否正确或是否被篡改等。JWT 组成分为三个部分，每个部分用点号连接，像是这样：

```text
HEADER.PAYLOAD.SIGNATURE
```

- HEADER：用于声明 算法 和 token 类型，alg 表明算法是 HS256，typ 表明类型是 JWT，如下：

```cpp
{
  "alg": "HS256",
  "typ": "JWT"
}
 
```

- PAYLOAD：存放所需传递的数据，有默认字段也可以自定义私有字段（这是未加密的，仅进行了编码，只能传递非敏感的信息），如下：

```cpp
{
    // 自带的默认字段
    "iss": "发行人",
    "exp": "到期时间",
    "sub": "主题",
    "aud": "用户",
    "nbf": "在此之前不可用",
    "iat": "发布时间",
    "jti": "ID用于标识JWT",
    // 自定义的字段
    "name": "Tom",
    "admin": true
}
```

- VERIFY SIGNATURE：结构如下，将 HEADER 、PAYLOAD 、secret密钥 三个部分分别进行 base64UrlEncode 的操作（secret 可以不 encode），然后使用自己所选的算法（在 HEADER 中指定）进行计算，得出的结果便是此部分的内容。

```cpp
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload) + "." +
  secret 或者 base64UrlEncode(secret)
)  
```

### **认证流程**

1. 客户端（浏览器）向服务端发送账号密码请求登录
2. 服务端校验账号密码并生成 JWT Token 将其返回
3. 客户端（浏览器）保存 JWT Token，下次需要请求时将其携带
4. 服务端校验 JWT Token 信息（像 VERIFY SIGNATURE 部分一样进行相同操作，取出 header 和 payload 并加上 secret 一同进行 encode，然后比对此部分是否一致），然后验证有效性、是否过期等等，通过后返回业务数据
5. 客户端（浏览器）收到业务数据，进行处理并使用

![img](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/e0446362-b93d-41bb-b3f3-9ba18ff9ff5c.jpg)