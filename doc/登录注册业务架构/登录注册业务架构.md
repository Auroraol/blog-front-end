# 登录流程

**单点登录**：就是指在多个服务中，用户只需要登录，一次就可以访问所有相互信任的服务，用户只需要退出登录一次，就可以退出所有的服务

**多端登录**：当用户登录之后，如果再换一个设备进行登录的话，可以设计将原来的那个设备上的账号踢掉线，或者两个设备上的账号同时登录，一同操作同一个用户的数据、业务等信息







## 实现方案一：JWT

使用JWT的方式，将用户的信息存储到token中，用户只需要在登录服务器登录一次，就可以生成一个token，将用户的相关信息存储到token中，然后将token存储到cookie中，之后再去访问其它相互信任的服务时，就可以直接拿token去访问，那个服务就会解析token，拿到用户信息，进而进行其它操作。

> JWT的结构：头部、载荷、签证

![image-20240305174245152](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174245152.png)

优点

- 去中心化
- 高并发

缺点

- 其它用户踢掉线无法实现

## 实现方案二：基于Redis缓存

使用Redis作为第三方存储，用户登录生成token后，将用户信息存储到Redis中(一般设置15-20过期), 而不是存储到token中了（这个token可以不基于JWT实现，只是普通的伪token即可，因为不存储信息），这样，下次浏览器再去访问其它服务器的时候，就可以使用token去Redis中获取用户信息，拿到用户信息后进行业务操作，然后返回响应数据。

在应用中,redis可以实现登录过期的功能,比如在用户提交登录时,通过设置一个过期时间,当用户30分钟内没有访问,redis就会自动将该用户的登录数据删除,从而释放宝贵的用户资源。

![image-20240305174352437](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174352437.png)

缺点

- 不是去中心化的，所有节点处理请求都依赖Redis，增加Redis负载
- 如何想要实现踢掉线的功能呢？只需将Redis中的用户信息删除即可，但是Redis中的用户信息存储的key是token，那么在其它浏览器中是拿不到这个token的，这样该如何才能去Redis中删除用户信息？

## 实现方案三：JWT+Redis缓存

使用Redis作为第三方存储，将userId存储到token中，用户登录生成token后，将用户信息存储到Redis中，key为userId，值为用户信息，下次访问其它服务器的时候，浏览器就会拿token去访问，然后服务器解析token，获取到userId，再根据userId去Redis中获取到用户信息，然后进行操作。

当想要进行踢其它用户掉线的时候，那么就需要在后台操作，后台可以直接获取到userId，然后拿userId去访问后台服务器，再拿userId去Redis中删除此用户信息，那么这个用户再访问的时候，就在Redis拿不到用户信息了，所以也就掉线了，需要重新登录。

> 踢掉线：假如你在打游戏，你发表了不良言论，我是管理员，我就要将你强制下线，这就是踢你掉线

![image-20240305174918690](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174918690.png)

缺点

- 不是去中心化的，所有节点处理请求都依赖Redis，增加Redis负载

## 实现方案四：CAS

CAS：集中式认证服务（Central Authentication Service）

> 使用Redis实现踢人掉线的功能，实际上就是使用了一个中心化的东西，而这个东西不止可以使Redis，还可以是一个服务。

浏览器去访问登录服务器，登录服务器返回一个token，登录成功。

如果浏览器没有携带token去访问业务服务器，那么请求到业务服务器之后，业务服务器再去请求登录服务器，登录服务器发现没有token，所以将此重定向到登录服务器，也就是让我们先去登录。

如果浏览器携带token去访问业务服务器，那么请求到业务服务器之后，业务服务器再去请求登录服务器，登录服务器发现token验证正确，返回给业务服务器一个此用户已登录，可以访问的消息，业务服务器收到消息之后，就可以继续执行接下来的业务了，最终执行完返回给浏览器一个响应数据，完成一次完整的请求。

![image-20240305174835381](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174835381.png)

- 可以处理踢掉线。
- 现成的代码直接可以用

缺点

- 每次验证是否登录，都需要访问登录服务器，增大了网络开销
- 增加了登陆中心的负载问题
- 当用户无权限的时候，重定向还会有问题



# jwt单点登陆和cas单点登陆有什么区别

## **CAS - Central Authentication Server**

CAS 全称 Central Authentication Server，也称作中央认证服务，是支持 JWT 的。

其分为两个部分：CAS 服务端（CAS Server） 和 CAS 客户端（CAS Client）。服务端负责认证工作，独立部署；客户端负责处理访问请求，需要登录时，重定向到服务端。

### **认证流程**

1. 浏览器向客户端请求提供某个受保护的资源。
2. 重定向到服务端进行认证
3. 用户进行身份认证
4. 服务端生成票据
5. 客户端向服务端验证票据
6. 验证成功返回用户信息

![img](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/d067e412-0eaa-48fd-8477-306e615f35e8.jpg)

## **JWT - JSON Web Token**

JWT 是一种用于在两方之间安全地表示声明的方法，是 token 思想的一种实现方式。

### **组成部分**

本质上就是一个字符串，但是其带有签名信息，接收后可以校验是否正确或是否被篡改等。JWT 组成分为三个部分，每个部分用点号连接，像是这样：

```text
HEADER.PAYLOAD.SIGNATURE
```

- HEADER：用于声明 算法 和 token 类型，alg 表明算法是 HS256，typ 表明类型是 JWT，如下：

```cpp
{
  "alg": "HS256",
  "typ": "JWT"
}
 
```

- PAYLOAD：存放所需传递的数据，有默认字段也可以自定义私有字段（这是未加密的，仅进行了编码，只能传递非敏感的信息），如下：

```cpp
{
    // 自带的默认字段
    "iss": "发行人",
    "exp": "到期时间",
    "sub": "主题",
    "aud": "用户",
    "nbf": "在此之前不可用",
    "iat": "发布时间",
    "jti": "ID用于标识JWT",
    // 自定义的字段
    "name": "Tom",
    "admin": true
}
```

- VERIFY SIGNATURE：结构如下，将 HEADER 、PAYLOAD 、secret密钥 三个部分分别进行 base64UrlEncode 的操作（secret 可以不 encode），然后使用自己所选的算法（在 HEADER 中指定）进行计算，得出的结果便是此部分的内容。

```cpp
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload) + "." +
  secret 或者 base64UrlEncode(secret)
)  
```

### **认证流程**

1. 客户端（浏览器）向服务端发送账号密码请求登录
2. 服务端校验账号密码并生成 JWT Token 将其返回
3. 客户端（浏览器）保存 JWT Token，下次需要请求时将其携带
4. 服务端校验 JWT Token 信息（像 VERIFY SIGNATURE 部分一样进行相同操作，取出 header 和 payload 并加上 secret 一同进行 encode，然后比对此部分是否一致），然后验证有效性、是否过期等等，通过后返回业务数据
5. 客户端（浏览器）收到业务数据，进行处理并使用

![img](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/e0446362-b93d-41bb-b3f3-9ba18ff9ff5c.jpg)





# JWT 进行前后端分离认证

## 后端结合SpringSecurity实现

当用户登录成功后，是需要将token传给前端的，然后让前端发送请求的时候携带这个token，请求报文中有了这个token才允许请求通过，否则返回401，无权限，

那如何将token传递给前端呢？即在登录认证成功后，Spring Security会去调用配置的`AuthenticationSuccessHandler` 中的 `onAuthenticationSuccess` 方法对登录成功的一些操作（即登录成功后需要返回给前端的数据就可以在这个方法中进行实现）

```java
@Component
public class LoginSuccessHandler implements AuthenticationSuccessHandler {

    @Resource
    private ObjectMapper objectMapper;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication) throws IOException, ServletException {
        // 设置响应编码格式
        response.setContentType("json/application;charset=utf-8");
        // 获取用户名
        String username = authentication.getName();
        // 生成 jwt
        String jwt = JWTUtil.createJWT(username);
        ServletOutputStream out = response.getOutputStream();
        // 将 jwt 返回给前端
        out.write(objectMapper.writeValueAsString(BackResult.success(jwt)).getBytes());
        out.close();
    }
}
```

首先认证成功后的数据是放在 `SecurityContextgHolder` 中的，内部默认使用的是 ThreadLocal 去存放认证信息（内部用了策略模式，默认采用的策略是用ThreadLocal），当一个请求结束后这个Authentication会移除，原本移除会放在Session里一同返回给前端，但现在把Session管理给静止了。

现在用的是JWT认证方式了，前端拿到这个token后，放在请求头中向后端发送请求时，后端得对这个token进行验证，如果验证成功了咱得从这个token中提取一些数据封装成Authentication放入 SecurityContextHolder 中，将 SecurityContextHolder 中的对应 Authentication 中的 `authenticated` 属性设置为 true，以表示认证成功，即这个请求认证成功了

**至于为什么要设置为 true，是因为在后面遇到 FilterSecurityInterceptor 拦截器判断是否授权时，会对这个进行判断，如果不是true的话会重新认证得到 Authentication 然后进行授权，到时候所响应的就是无权限访问401了。**

具体代码如下，下面是小编自定义的 JWTAuthenticationFilter，内部是 sysUsreService 对象是用来根据获取数据库的用户信息的，而 URL_PERMITTED_LIST 中的具体 uri 是小编配置的无需通过Token认证即可请求服务器端的，这些都是根据具体需求自己配置的：

```java
@Slf4j
public class JWTAuthenticationFilter extends BasicAuthenticationFilter {

    @Resource
    private SysUserService sysUserService;

    private static final String[] URL_PERMITTED_LIST = {
            "/api/auth/login",
            "/api/auth/logout",
            "/captcha",
            "/password",
            "/image/**",
            "/test/**"
    };

    public JWTAuthenticationFilter(@Autowired AuthenticationManager authenticationManager) {
        super(authenticationManager);
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain)
            throws IOException, ServletException {

        String token = request.getHeader("token");
        log.info("token--------{}",token);
        System.out.println("请求 URL：" + request.getRequestURI());
        if(Arrays.asList(URL_PERMITTED_LIST).contains(request.getRequestURI())){
            chain.doFilter(request,response);
            return;
        }
        
        // 验证Token，如果验证失败对失败进行处理
        CheckResult checkResult = JWTUtil.validateJWT(token);
        if(!checkResult.isSuccess()){
            switch(checkResult.getErrCode()){
                case JWTConstant.JWT_ERRCODE_NULL: throw new JwtException("Token 不存在");
                case JWTConstant.JWT_ERRCODE_EXPIRE: throw new JwtException("Token 已过期");
                case JWTConstant.JWT_ERRCODE_FAIL: throw new JwtException("Token 认证过期");
            }
        }
        // 解析jwt去获取用户名
        Claims claims = checkResult.getClaims();
        String username = claims.getSubject();
        SysUser sysUser = sysUserService.getByUserName(username);
        // 根据查询的用户信息封装成一个Authentication用户认证信息
        UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(sysUser.getUsername(),null,new ArrayList<GrantedAuthority>());
        // 将得到的用户认证信息填入到上下文中
        SecurityContextHolder.getContext().setAuthentication(auth);
        System.out.println(SecurityContextHolder.getContext());
        // 放行
        chain.doFilter(request,response);
    }
}
```

在Security配置SecurityFilterChain时进行如下配置，将过滤器添加到过滤器链中。

```java
        // 添加自定义的过滤器-基本认证过滤器，让每个请求都得经过jwt认证...
        http.addFilter(jwtAuthenticationFilter(http));
```

可以说这 5 步，这 JWT 认证的后端部分就算完成了。

## 前端Vue3结合Pinia、Axios实现

1. 下载 Pinia、Axios
   `npm install axios`
   `npm install pinia`
   然后在 main.js 中，使用 pinia 这个插件。

定义自定义的 Store，登录成功后可通过调用 SET_TOKEN 方法将 token 存入到 sessionStorage 中。

```ts
import {defineStore} from "pinia";

export const piniaStore = defineStore("XCStore",{
    state: () => ({
        token: 'xxx'
    }),
    actions:{
        SET_TOKEN(state,token){
            state.token = token
            sessionStorage.setItem("token",token)
        }
    },
    getters : {
        GET_TOKEN(){
            return sessionStorage.getItem("token")
        }
    }
})

```

通过了登录成功，通过调用 store 中的 SET_TOKEN 方法将登录认证传过来的 token 添加到 sessionStorage 中。

```ts
    function submit() {
        formRef.value.validate(async(valid)=>{
            if(valid) {
                try {
                    let result = await RequestUtil.post(`api/auth/login`, formData.value);
                    let data = result.data
                    if(data.status === 200){
                        piniaStore.SET_TOKEN(store.$state,data.data)  //token 添加到 sessionStorage 
                    }else {
                        ElMessage.error(data.msg)
                    }
                }catch (err) {
                    console.log("error :" + err)
                    ElMessage.error("服务器出错，请联系管理员")
                }
            } else {
                console.log("验证失败")
            }
        })
    }


```

给 Axios 添加请求拦截器，让每个 Axios 请求都携带上这个 token。

```ts
// 引入axios
import axios from 'axios';

let baseUrl="http://localhost:8081/";
// 创建axios实例
const httpService = axios.create({
    // url前缀-'http:xxx.xxx'
    // baseURL: process.env.BASE_API, // 需自定义
    baseURL:"http://localhost:8081/",
    // 请求超时时间
    timeout: 3000 // 需自定义
});

//添加请求和响应拦截器
// 添加请求拦截器
httpService.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    config.headers.token=window.sessionStorage.getItem('token');  //前端发送请求的时候携带这个 token                                                               [][][]][[]]
    return config;
}, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
});

// 添加响应拦截器
httpService.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
}, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
});

/*网络请求部分*/

/*
 *  get请求
 *  url:请求地址
 *  params:参数
 * */
export function get(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'get',
            params: params
        }).then(response => {
            resolve(response);
        }).catch(error => {
            reject(error);
        });
    });
}

/*
 *  post请求
 *  url:请求地址
 *  params:参数
 * */
export function post(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'post',
            data: params
        }).then(response => {
            console.log(response)
            resolve(response);
        }).catch(error => {
            console.log(error)
            reject(error);
        });
    });
}

/*
 *  文件上传
 *  url:请求地址
 *  params:参数
 * */
export function fileUpload(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'post',
            data: params,
            headers: { 'Content-Type': 'multipart/form-data' }
        }).then(response => {
            resolve(response);
        }).catch(error => {
            reject(error);
        });
    });
}

export function getServerUrl(){
    return baseUrl;
}

export default {
    get,
    post,
    fileUpload,
    getServerUrl
}


```

![请添加图片描述](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/acac0000fd394eca81bf4c5be8088a99.gif)









# spring Security + Redis + JWT实现动态权限管理

实现[单点登录](https://so.csdn.net/so/search?q=单点登录&spm=1001.2101.3001.7020)（Single Sign-On, SSO）需要以下步骤：

1. 用户登录后，生成JWT Token并将其存储到Redis中。
2. 将JWT Token返回给客户端，并在响应头中设置Authorization字段，值为Bearer加上JWT Token。
3. 客户端在每次请求时，在请求头中带上Authorization字段，值为Bearer加上JWT Token。
4. 服务端在接收到请求时，先从请求头中获取JWT Token，并解析出其中的用户信息。然后再到Redis中验证Token的唯一性和有效期。
5. 如果验证通过，则允许用户访问资源；否则拒绝访问。

当用户登录成功后,  去生成JWT Token并保存到Redis中, 然后将token传给前端的

在Spring Security的配置类中(前端拿到这个token后，放在请求头中向后端发送请求时，后端得对这个token进行验证，如果验证成功了咱得从这个token中提取一些数据封装成Authentication放入 SecurityContextHolder 中，将 SecurityContextHolder 中的对应 Authentication 中的 `authenticated` 属性设置为 true，以表示认证成功，即这个请求认证成功了)

- 首先，pom.xml文件中引入以下依赖

- ```cobol
  <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-api</artifactId>
      <version>0.11.2</version>
  </dependency>
   
  <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-impl</artifactId>
      <version>0.11.2</version>
      <scope>runtime</scope>
  </dependency>
   
  <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-jackson</artifactId>
      <version>0.11.2</version>
      <scope>runtime</scope>
  </dependency>
   
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
  </dependency>
  ```

  然后，在application.yml文件中配置[JWT](https://so.csdn.net/so/search?q=JWT&spm=1001.2101.3001.7020) Token的相关属性（secret为加密密钥，expiration为有效期）：

  ```vbnet
  jwt:
    secret: mysecretkey
    expiration: 600
  ```

  

- 然后，创建一个JwtUtil类，用于生成和解析JWT Token：

- ```typescript
  import io.jsonwebtoken.Claims;
  import io.jsonwebtoken.Jwts;
  import io.jsonwebtoken.SignatureAlgorithm;
  import io.jsonwebtoken.security.Keys;
  import org.springframework.beans.factory.annotation.Value;
  import org.springframework.stereotype.Component;
   
  import javax.crypto.SecretKey;
  import java.util.Date;
  import java.util.HashMap;
  import java.util.Map;
   
  @Component
  public class JwtUtil {
      @Value("${jwt.secret}")
      private String secret;
   
      @Value("${jwt.expiration}")
      private Long expiration;
   
      private SecretKey key = Keys.hmacShaKeyFor(secret.getBytes());
   
      public String generateToken(String username) {
          Date now = new Date();
          Date expiryDate = new Date(now.getTime() + expiration * 1000);
   
          Map<String, Object> claims = new HashMap<>();
          claims.put("sub", username);
          claims.put("iat", now);
          claims.put("exp", expiryDate);
   
          return Jwts.builder()
                  .setClaims(claims)
                  .signWith(key, SignatureAlgorithm.HS512)
                  .compact();
      }
   
      public String getUsernameFromToken(String token) {
          Claims claims = Jwts.parserBuilder()
                  .setSigningKey(key)
                  .build()
                  .parseClaimsJws(token)
                  .getBody();
   
          return claims.getSubject();
      }
      
      public Long getExpiration() {
          return expiration;
      }
  }
  ```

  创建一个JwtFilter类，用于验证JWT Token的唯一性和有效性：

  ```java
  import com.alibaba.fastjson.JSONObject;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.data.redis.core.RedisTemplate;
  import org.springframework.http.HttpStatus;
  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  import org.springframework.security.core.context.SecurityContextHolder;
  import org.springframework.stereotype.Component;
  import org.springframework.util.StringUtils;
  import org.springframework.web.filter.OncePerRequestFilter;
   
  import javax.servlet.FilterChain;
  import javax.servlet.ServletException;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  import java.util.concurrent.TimeUnit;
   
  @Component
  public class JwtFilter extends OncePerRequestFilter {
      @Autowired
      private JwtUtil jwtUtil;
   
      @Autowired
      private RedisTemplate<String, Object> redisTemplate;
   
      @Override
      protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {
          String authToken = httpServletRequest.getHeader("Authorization");
          if (StringUtils.hasText(authToken) && authToken.startsWith("Bearer ")) {
              authToken = authToken.substring(7);
   
              String username = jwtUtil.getUsernameFromToken(authToken);
              Object tokenInRedis = redisTemplate.opsForValue().get(username);
              if (tokenInRedis == null || !tokenInRedis.equals(authToken)) {
                  httpServletResponse.setContentType("application/json;charset=UTF-8");
                  httpServletResponse.setStatus(HttpStatus.UNAUTHORIZED.value());
                  JSONObject result = new JSONObject();
                  result.put("status", HttpStatus.UNAUTHORIZED.value());
                  result.put("message", "Token验证失败或已过期，请重新登录！");
                  httpServletResponse.getWriter().write(result.toString());
   
                  return;
              }
   
  if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
              UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username, null, null);
              SecurityContextHolder.getContext().setAuthentication(authenticationToken);
   
              redisTemplate.opsForValue().set(username, authToken, jwtUtil.getExpiration(), TimeUnit.SECONDS);
          }
      }
   
   
          filterChain.doFilter(httpServletRequest, httpServletResponse);
      }
  }
  ```

  **在登录控制器中生成JWT Token并保存到Redis中：**

  ```typescript
  @RestController
  public class LoginController {
      @Autowired
      private JwtUtil jwtUtil;
   
      @Autowired
      private RedisTemplate<String, Object> redisTemplate;
   
      @PostMapping("/login")
      public String login(@RequestParam String username, @RequestParam String password) {
          // TODO: 用户名和密码验证
          String token = jwtUtil.generateToken(username);
          redisTemplate.opsForValue().set(username, token, jwtUtil.getExpiration(), TimeUnit.SECONDS);
   
          return token;
      }
  }
  ```

  **最后，在Spring Security的配置类中添加JWT Token的过滤器：**

  ```scala
  @Configuration
  @EnableWebSecurity
  public class SecurityConfig extends WebSecurityConfigurerAdapter {
      @Autowired
      private JwtFilter jwtFilter;
   
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.csrf().disable()
                  .authorizeRequests()
                  .anyRequest()
                  .authenticated()
                  .and()
                  .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
      }
  }
  ```

  登录控制层

  ```kotlin
  
  import cn.chatmind.demo.mapper.UserMapper;
  import cn.chatmind.demo.model.User;
  import com.alibaba.fastjson.JSONObject;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.web.bind.annotation.*;
   
  @RestController
  @RequestMapping("/api")
  public class UserController {
      @Autowired
      private UserMapper userMapper;
   
      @Autowired
      private JwtUtil jwtUtil;
   
      @PostMapping("/login")
      public JSONObject login(@RequestBody User user) {
          JSONObject responseJson = new JSONObject();
   
          User existUser = userMapper.findByUsernameAndPassword(user);
   
          if (existUser != null) {
              String token = jwtUtil.generateToken(existUser.getUsername());
              responseJson.put("token", token);
   
              return responseJson;
          } else {
              responseJson.put("error", "Bad Request");
              responseJson.put("message", "Invalid username or password.");
              return responseJson;
          }
      }
   
      @GetMapping("/users/{id}")
      public User getUserById(@PathVariable("id") Integer id) {
          return userMapper.findUserById(id);
      }
  }
  ```

  以上为一个基础的使用Spring Boot、MyBatis、Redis和JWT实现用户登录认证的完整示例。具体实现中可以根据需求进行更改和优化。

# todo

[2023-10 最新jsonwebtoken-jjwt 0.12.3 基本使用-CSDN博客](https://blog.csdn.net/qq_50969362/article/details/134100542)