# 

登录流程

**单点登录**：就是指在多个服务中，用户只需要登录，一次就可以访问所有相互信任的服务，用户只需要退出登录一次，就可以退出所有的服务

**多端登录**：当用户登录之后，如果再换一个设备进行登录的话，可以设计将原来的那个设备上的账号踢掉线，或者两个设备上的账号同时登录，一同操作同一个用户的数据、业务等信息

## 实现方案一：JWT

使用JWT的方式，将用户的信息存储到token中，用户只需要在登录服务器登录一次，就可以生成一个token，将用户的相关信息存储到token中，然后将token存储到cookie中，之后再去访问其它相互信任的服务时，就可以直接拿token去访问，那个服务就会解析token，拿到用户信息，进而进行其它操作。

> JWT的结构：头部、载荷、签证

![image-20240305174245152](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174245152.png)

优点

- 去中心化
- 高并发

缺点

- 其它用户踢掉线无法实现

## 实现方案二：基于Redis缓存

使用Redis作为第三方存储，用户登录生成token后，将用户信息存储到Redis中(一般设置15-20过期), 而不是存储到token中了（这个token可以不基于JWT实现，只是普通的伪token即可，因为不存储信息），这样，下次浏览器再去访问其它服务器的时候，就可以使用token去Redis中获取用户信息，拿到用户信息后进行业务操作，然后返回响应数据。

在应用中,redis可以实现登录过期的功能,比如在用户提交登录时,通过设置一个过期时间,当用户30分钟内没有访问,redis就会自动将该用户的登录数据删除,从而释放宝贵的用户资源。

![image-20240305174352437](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174352437.png)

缺点

- 不是去中心化的，所有节点处理请求都依赖Redis，增加Redis负载
- 如何想要实现踢掉线的功能呢？只需将Redis中的用户信息删除即可，但是Redis中的用户信息存储的key是token，那么在其它浏览器中是拿不到这个token的，这样该如何才能去Redis中删除用户信息？

## 实现方案三：JWT+Redis缓存

使用Redis作为第三方存储，将userId存储到token中，用户登录生成token后，将用户信息存储到Redis中，key为userId，值为用户信息，下次访问其它服务器的时候，浏览器就会拿token去访问，然后服务器解析token，获取到userId，再根据userId去Redis中获取到用户信息，然后进行操作。

当想要进行踢其它用户掉线的时候，那么就需要在后台操作，后台可以直接获取到userId，然后拿userId去访问后台服务器，再拿userId去Redis中删除此用户信息，那么这个用户再访问的时候，就在Redis拿不到用户信息了，所以也就掉线了，需要重新登录。

> 踢掉线：假如你在打游戏，你发表了不良言论，我是管理员，我就要将你强制下线，这就是踢你掉线

![image-20240305174918690](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174918690.png)

缺点

- 不是去中心化的，所有节点处理请求都依赖Redis，增加Redis负载

## 实现方案四：CAS

CAS：集中式认证服务（Central Authentication Service）

> 使用Redis实现踢人掉线的功能，实际上就是使用了一个中心化的东西，而这个东西不止可以使Redis，还可以是一个服务。

浏览器去访问登录服务器，登录服务器返回一个token，登录成功。

如果浏览器没有携带token去访问业务服务器，那么请求到业务服务器之后，业务服务器再去请求登录服务器，登录服务器发现没有token，所以将此重定向到登录服务器，也就是让我们先去登录。

如果浏览器携带token去访问业务服务器，那么请求到业务服务器之后，业务服务器再去请求登录服务器，登录服务器发现token验证正确，返回给业务服务器一个此用户已登录，可以访问的消息，业务服务器收到消息之后，就可以继续执行接下来的业务了，最终执行完返回给浏览器一个响应数据，完成一次完整的请求。

![image-20240305174835381](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240305174835381.png)

- 可以处理踢掉线。
- 现成的代码直接可以用

缺点

- 每次验证是否登录，都需要访问登录服务器，增大了网络开销
- 增加了登陆中心的负载问题
- 当用户无权限的时候，重定向还会有问题



# jwt单点登陆和cas单点登陆有什么区别

## **CAS - Central Authentication Server**

CAS 全称 Central Authentication Server，也称作中央认证服务，是支持 JWT 的。

其分为两个部分：CAS 服务端（CAS Server） 和 CAS 客户端（CAS Client）。服务端负责认证工作，独立部署；客户端负责处理访问请求，需要登录时，重定向到服务端。

### **认证流程**

1. 浏览器向客户端请求提供某个受保护的资源。
2. 重定向到服务端进行认证
3. 用户进行身份认证
4. 服务端生成票据
5. 客户端向服务端验证票据
6. 验证成功返回用户信息

![img](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/d067e412-0eaa-48fd-8477-306e615f35e8.jpg)

## **JWT - JSON Web Token**

JWT 是一种用于在两方之间安全地表示声明的方法，是 token 思想的一种实现方式。

### **组成部分**

本质上就是一个字符串，但是其带有签名信息，接收后可以校验是否正确或是否被篡改等。JWT 组成分为三个部分，每个部分用点号连接，像是这样：

```text
HEADER.PAYLOAD.SIGNATURE
```

- HEADER：用于声明 算法 和 token 类型，alg 表明算法是 HS256，typ 表明类型是 JWT，如下：

```cpp
{
  "alg": "HS256",
  "typ": "JWT"
}
 
```

- PAYLOAD：存放所需传递的数据，有默认字段也可以自定义私有字段（这是未加密的，仅进行了编码，只能传递非敏感的信息），如下：

```cpp
{
    // 自带的默认字段
    "iss": "发行人",
    "exp": "到期时间",
    "sub": "主题",
    "aud": "用户",
    "nbf": "在此之前不可用",
    "iat": "发布时间",
    "jti": "ID用于标识JWT",
    // 自定义的字段
    "name": "Tom",
    "admin": true
}
```

- VERIFY SIGNATURE：结构如下，将 HEADER 、PAYLOAD 、secret密钥 三个部分分别进行 base64UrlEncode 的操作（secret 可以不 encode），然后使用自己所选的算法（在 HEADER 中指定）进行计算，得出的结果便是此部分的内容。

```cpp
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload) + "." +
  secret 或者 base64UrlEncode(secret)
)  
```

### **认证流程**

1. 客户端（浏览器）向服务端发送账号密码请求登录
2. 服务端校验账号密码并生成 JWT Token 将其返回
3. 客户端（浏览器）保存 JWT Token，下次需要请求时将其携带
4. 服务端校验 JWT Token 信息（像 VERIFY SIGNATURE 部分一样进行相同操作，取出 header 和 payload 并加上 secret 一同进行 encode，然后比对此部分是否一致），然后验证有效性、是否过期等等，通过后返回业务数据
5. 客户端（浏览器）收到业务数据，进行处理并使用

![img](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/e0446362-b93d-41bb-b3f3-9ba18ff9ff5c.jpg)





# JWT 进行前后端分离认证

## 后端结合SpringSecurity实现

当用户登录成功后，是需要将token传给前端的，然后让前端发送请求的时候携带这个token，请求报文中有了这个token才允许请求通过，否则返回401，无权限，

那如何将token传递给前端呢？即在登录认证成功后，Spring Security会去调用配置的`AuthenticationSuccessHandler` 中的 `onAuthenticationSuccess` 方法对登录成功的一些操作（即登录成功后需要返回给前端的数据就可以在这个方法中进行实现）

```java
@Component
public class LoginSuccessHandler implements AuthenticationSuccessHandler {

    @Resource
    private ObjectMapper objectMapper;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication) throws IOException, ServletException {
        // 设置响应编码格式
        response.setContentType("json/application;charset=utf-8");
        // 获取用户名
        String username = authentication.getName();
        // 生成 jwt
        String jwt = JWTUtil.createJWT(username);
        ServletOutputStream out = response.getOutputStream();
        // 将 jwt 返回给前端
        out.write(objectMapper.writeValueAsString(BackResult.success(jwt)).getBytes());
        out.close();
    }
}
```

首先认证成功后的数据是放在 `SecurityContextgHolder` 中的，内部默认使用的是 ThreadLocal 去存放认证信息（内部用了策略模式，默认采用的策略是用ThreadLocal），当一个请求结束后这个Authentication会移除，原本移除会放在Session里一同返回给前端，但现在把Session管理给静止了。

现在用的是JWT认证方式了，前端拿到这个token后，放在请求头中向后端发送请求时，后端得对这个token进行验证，如果验证成功了咱得从这个token中提取一些数据封装成Authentication放入 SecurityContextHolder 中，将 SecurityContextHolder 中的对应 Authentication 中的 `authenticated` 属性设置为 true，以表示认证成功，即这个请求认证成功了

**至于为什么要设置为 true，是因为在后面遇到 FilterSecurityInterceptor 拦截器判断是否授权时，会对这个进行判断，如果不是true的话会重新认证得到 Authentication 然后进行授权，到时候所响应的就是无权限访问401了。**

具体代码如下，下面是小编自定义的 JWTAuthenticationFilter，内部是 sysUsreService 对象是用来根据获取数据库的用户信息的，而 URL_PERMITTED_LIST 中的具体 uri 是小编配置的无需通过Token认证即可请求服务器端的，这些都是根据具体需求自己配置的：

```java
@Slf4j
public class JWTAuthenticationFilter extends BasicAuthenticationFilter {

    @Resource
    private SysUserService sysUserService;

    private static final String[] URL_PERMITTED_LIST = {
            "/api/auth/login",
            "/api/auth/logout",
            "/captcha",
            "/password",
            "/image/**",
            "/test/**"
    };

    public JWTAuthenticationFilter(@Autowired AuthenticationManager authenticationManager) {
        super(authenticationManager);
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain)
            throws IOException, ServletException {

        String token = request.getHeader("token");
        log.info("token--------{}",token);
        System.out.println("请求 URL：" + request.getRequestURI());
        if(Arrays.asList(URL_PERMITTED_LIST).contains(request.getRequestURI())){
            chain.doFilter(request,response);
            return;
        }
        
        // 验证Token，如果验证失败对失败进行处理
        CheckResult checkResult = JWTUtil.validateJWT(token);
        if(!checkResult.isSuccess()){
            switch(checkResult.getErrCode()){
                case JWTConstant.JWT_ERRCODE_NULL: throw new JwtException("Token 不存在");
                case JWTConstant.JWT_ERRCODE_EXPIRE: throw new JwtException("Token 已过期");
                case JWTConstant.JWT_ERRCODE_FAIL: throw new JwtException("Token 认证过期");
            }
        }
        // 解析jwt去获取用户名
        Claims claims = checkResult.getClaims();
        String username = claims.getSubject();
        SysUser sysUser = sysUserService.getByUserName(username);
        // 根据查询的用户信息封装成一个Authentication用户认证信息
        UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(sysUser.getUsername(),null,new ArrayList<GrantedAuthority>());
        // 将得到的用户认证信息填入到上下文中
        SecurityContextHolder.getContext().setAuthentication(auth);
        System.out.println(SecurityContextHolder.getContext());
        // 放行
        chain.doFilter(request,response);
    }
}
```

在Security配置SecurityFilterChain时进行如下配置，将过滤器添加到过滤器链中。

```java
        // 添加自定义的过滤器-基本认证过滤器，让每个请求都得经过jwt认证...
        http.addFilter(jwtAuthenticationFilter(http));
```

可以说这 5 步，这 JWT 认证的后端部分就算完成了。

## 前端Vue3结合Pinia、Axios实现

1. 下载 Pinia、Axios
   `npm install axios`
   `npm install pinia`
   然后在 main.js 中，使用 pinia 这个插件。

定义自定义的 Store，登录成功后可通过调用 SET_TOKEN 方法将 token 存入到 sessionStorage 中。

```ts
import {defineStore} from "pinia";

export const piniaStore = defineStore("XCStore",{
    state: () => ({
        token: 'xxx'
    }),
    actions:{
        SET_TOKEN(state,token){
            state.token = token
            sessionStorage.setItem("token",token)
        }
    },
    getters : {
        GET_TOKEN(){
            return sessionStorage.getItem("token")
        }
    }
})

```

通过了登录成功，通过调用 store 中的 SET_TOKEN 方法将登录认证传过来的 token 添加到 sessionStorage 中。

```ts
    function submit() {
        formRef.value.validate(async(valid)=>{
            if(valid) {
                try {
                    let result = await RequestUtil.post(`api/auth/login`, formData.value);
                    let data = result.data
                    if(data.status === 200){
                        piniaStore.SET_TOKEN(store.$state,data.data)  //token 添加到 sessionStorage 
                    }else {
                        ElMessage.error(data.msg)
                    }
                }catch (err) {
                    console.log("error :" + err)
                    ElMessage.error("服务器出错，请联系管理员")
                }
            } else {
                console.log("验证失败")
            }
        })
    }


```

给 Axios 添加请求拦截器，让每个 Axios 请求都携带上这个 token。

```ts
// 引入axios
import axios from 'axios';

let baseUrl="http://localhost:8081/";
// 创建axios实例
const httpService = axios.create({
    // url前缀-'http:xxx.xxx'
    // baseURL: process.env.BASE_API, // 需自定义
    baseURL:"http://localhost:8081/",
    // 请求超时时间
    timeout: 3000 // 需自定义
});

//添加请求和响应拦截器
// 添加请求拦截器
httpService.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    config.headers.token=window.sessionStorage.getItem('token');  //前端发送请求的时候携带这个 token                                                               [][][]][[]]
    return config;
}, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
});

// 添加响应拦截器
httpService.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
}, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
});

/*网络请求部分*/

/*
 *  get请求
 *  url:请求地址
 *  params:参数
 * */
export function get(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'get',
            params: params
        }).then(response => {
            resolve(response);
        }).catch(error => {
            reject(error);
        });
    });
}

/*
 *  post请求
 *  url:请求地址
 *  params:参数
 * */
export function post(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'post',
            data: params
        }).then(response => {
            console.log(response)
            resolve(response);
        }).catch(error => {
            console.log(error)
            reject(error);
        });
    });
}

/*
 *  文件上传
 *  url:请求地址
 *  params:参数
 * */
export function fileUpload(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'post',
            data: params,
            headers: { 'Content-Type': 'multipart/form-data' }
        }).then(response => {
            resolve(response);
        }).catch(error => {
            reject(error);
        });
    });
}

export function getServerUrl(){
    return baseUrl;
}

export default {
    get,
    post,
    fileUpload,
    getServerUrl
}


```

![请添加图片描述](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/acac0000fd394eca81bf4c5be8088a99.gif)









# springboot+spring Security + Redis + JWT实现单点登录

实现[单点登录](https://so.csdn.net/so/search?q=单点登录&spm=1001.2101.3001.7020)（Single Sign-On, SSO）需要以下步骤：

1. 用户登录后，生成JWT Token(一般过期时间设置成30分钟)并将其存储到Redis中。
2. 将JWT Token返回给客户端，并在响应头中设置Authorization字段，值为accessToken加上JWT Token。
3. 客户端在每次请求时，在请求头中带上Authorization字段，值为Bearer加上JWT Token。
4. 服务端在接收到请求时，先从请求头中获取JWT Token，并解析出其中的用户信息。然后再到Redis中验证Token的唯一性和有效期。
5. 如果验证通过，则允许用户访问资源；否则拒绝访问。需要用户信息的数据要使用Spring Security之安全上下文得到访问者账号的有关信息, 再到对应的mysql查询数据

当用户登录成功后,  去生成JWT Token并保存到Redis中, 然后将token传给前端的

## 代码见

<img src="%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240313164550529.png" alt="image-20240313164550529" style="zoom:67%;" />

## pom.xm

```xml
   <!--   token加密 -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
            <version>0.12.3</version>
        </dependency>
        <!--   token加密结束 -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-core</artifactId>
        </dependency>
	 <!-- mysql -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.2.20</version>
            <scope>compile</scope>
        </dependency>
        <!-- mybatisplus+数据库相关开始-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-core</artifactId>
            <version>3.5.3.1</version>
        </dependency>
        <!--使用mybatisplus常用CRUD接口方式,可以不用写sql语句-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.3.1</version>
        </dependency>
        <!--使用mybatisplus代码生成器, 具体用法见官网-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-generator</artifactId>
            <version>3.5.3.1</version>
        </dependency>
        <!--mybatisplus+数据库相关结束-->
         <!--redis相关-->
        <!-- redisson-->
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson-spring-boot-starter</artifactId>
            <version>3.17.0</version>
        </dependency>
        <!--lettuce redis连接池-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
```

## 登录

![image-20240313164135392](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240313164135392.png)

### Token 实体类

#### Token 实体类

```java
package com.mszlu.shop.common.security;

import lombok.Data;

/**
 * Token 实体类
 */
@Data
public class Token {
    /**
     * 访问token
     */
    private String accessToken;

    /**
     * 刷新token
     */
    private String refreshToken;

}
```

#### Token 实体类存放的信息

保存登录用户的部分信息

```java
package com.lfj.blog.common.security;


import lombok.AllArgsConstructor;
import lombok.Data;

import java.io.Serializable;

/**
 * @Author: LFJ
 * @Date: 2024-03-09 17:32
 *  存储到Token中的信息
 */
@Data
@AllArgsConstructor
public class AuthUser implements Serializable {

	/**
	 * 用户名
	 */
	private String username;

	/**
	 * 昵称
	 */
	private String nickName;

	/**
	 * id
	 */
	private String id;

	/**
	 * 长期有效（用于手机app登录场景或者信任场景等）
	 */
	private Boolean longTerm = false;

	/**
	 * @see UserEnums
	 * 角色
	 */
	private UserEnums role;


	/**
	 * 是否是超级管理员
	 */
	private Boolean isSuper = false;

	public AuthUser(String username, String id, String nickName, UserEnums role) {
		this.username = username;
		this.id = id;
		this.role = role;
		this.nickName = nickName;
	}

	public AuthUser(String username, String id, UserEnums manager, String nickName, Boolean isSuper) {
		this.username = username;
		this.id = id;
		this.role = manager;
		this.isSuper = isSuper;
		this.nickName = nickName;
	}
}

```

### 角色枚举

```java
package com.lfj.blog.common.security;

/**
 * @Author: LFJ
 * @Date: 2024-03-09 17:33
 * token角色类型
 */
public enum UserEnums {
	/**
	 * 角色
	 */
	MANAGER("管理员"),
	USER("用户");
	private final String role;

	UserEnums(String role) {
		this.role = role;
	}

	public String getRole() {
		return role;
	}
}

```

### jjwt工具类

注意:  jwt  设置过期时间后再前端判断的

```java
package com.lfj.blog.utils.token;

import com.alibaba.fastjson2.JSON;
import io.jsonwebtoken.Jwts;

import java.util.Date;

/**
 * @Author: LFJ
 * @Date: 2024-03-09 15:21
 */
public class TokenUtils {
	public static String createToken(String username, Object claim, Long expirationTime) {
		//JWT 生成
		return Jwts.builder()
				//jwt 私有声明
				.claim(SecurityKey.USER_CONTEXT, JSON.toJSONString(claim))
				//JWT的主体
				.subject(username)
				//失效时间 当前时间+过期分钟
				.expiration(new Date(System.currentTimeMillis() + expirationTime))
				//签名算法和密钥
				.signWith(SecretKeyUtil.generalKey())
				.compact();
	}
}

```

#### SecretKeyUtil

```java
package com.lfj.blog.utils.token;

import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.apache.tomcat.util.codec.binary.Base64;


import javax.crypto.SecretKey;
import java.io.UnsupportedEncodingException;

/**
 * @Author: LFJ
 * @Date: 2024-03-09 15:23
 * SignWithUtil
 */
public class SecretKeyUtil {
	public static SecretKey generalKey() {
		byte[] encodedKey = Base64.decodeBase64("bXN6bHVfMTIzYXNkYWRnYXVoZCFAIyQlNkFERkdHS0pIR1lURkRZVVM=");//自定义
		javax.crypto.SecretKey key = Keys.hmacShaKeyFor(encodedKey);
		return key;
	}

	public static SecretKey generalKeyByDecoders() {
		return Keys.hmacShaKeyFor(Decoders.BASE64.decode("bXN6bHVfMTIzYXNkYWRnYXVoZCFAIyQlNkFERkdHS0pIR1lURkRZVVM="));

	}

	public static void main(String[] args) throws UnsupportedEncodingException {
		System.out.println(Base64.encodeBase64String("mszlu_123asdadgauhd!@#$%6ADFGGKJHGYTFDYUS".getBytes()));
		System.out.println(new String(SecretKeyUtil.generalKeyByDecoders().getEncoded()));
	}
}

```

#### SecurityKey

```java
package com.lfj.blog.utils.token;

/**
 * @Author: LFJ
 * @Date: 2024-03-09 15:24
 */
public class SecurityKey {
	public static final String USER_CONTEXT = "userContext";

	public static final String ACCESS_TOKEN = "accessToken";
}

```

### 核心实现

```java
package com.lfj.blog.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.lfj.blog.common.cache.CachePrefix;
import com.lfj.blog.common.security.AuthUser;
import com.lfj.blog.common.security.Token;
import com.lfj.blog.common.security.UserEnums;
import com.lfj.blog.common.vo.ResponseResult;
import com.lfj.blog.entity.User;
import com.lfj.blog.mapper.UserMapper;
import com.lfj.blog.service.UserService;
import com.lfj.blog.utils.token.TokenUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.ObjectUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.TimeUnit;
/**
 * @author 16658
 * @description 针对表【user】的数据库操作Service实现
 * @createDate 2024-03-09 17:46:34
 */
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User>
		implements UserService {

	@Autowired
	private StringRedisTemplate redisTemplate;

	public static void main(String[] args) {
		System.out.println(new BCryptPasswordEncoder().encode("123456"));
	}

	@Override
	public ResponseResult<Token> usernameLogin(String username, String password) {
		/**
		 1. 根据用户名查找Member信息
		 2. 如果为null，就是用户不存在
		 3. 密码进行匹配，如果不匹配 密码不正确
		 4. jwt 生成token
		 5. jwt 生成token, token放入redis当中，accessToken 过期短， refreshToken 过期长
		 **/
		LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<User>()
				.eq(User::getUsername, username);
		List<User> userList = this.list(queryWrapper);

		User user = userList.get(0);
		if (ObjectUtils.isEmpty(user)) {
			return ResponseResult.accountNotFoundError();
		}

		//用的security的密码类
		if (!new BCryptPasswordEncoder().matches(password, user.getPassword())) {
			return ResponseResult.accountError();
		}

		//一般会登录的时候，记录 用户的最后一次登录时间
		//MQ 考虑使用mq 把信息发到mq当中，由mq的消费者 来去更新1
		user.setRecentlylanded(LocalDateTime.now());
		this.updateById(user);

		Token token = genToken(user);
		return ResponseResult.success(token);
	}

	private Token genToken(User user) {
		Token token = new Token();
		// token存放信息
		AuthUser authUser = new AuthUser(user.getUsername(), String.valueOf(user.getId()),
				user.getUsername(), UserEnums.USER);
		// 7天(一般过期时间设置成30分钟)
		String jwtAccessToken = TokenUtils.createToken(user.getUsername(), authUser, 30 * 24 * 60 * 60 * 1000L);
		token.setAccessToken(jwtAccessToken);
		redisTemplate.opsForValue().set(CachePrefix.ACCESS_TOKEN.name() + UserEnums.USER.name() + jwtAccessToken
				,"1", 30, TimeUnit.DAYS); // 储存到Redis中 前缀+用户类型+jwtToken

		// 15天
		//设置刷新token，当accessToken过期的时候，可以通过refreshToken来 重新获取accessToken 而不用访问数据库
		String jwtRefreshToken = TokenUtils.createToken(user.getUsername(), authUser, 15 * 24 * 60 * 60 * 1000L);
		token.setRefreshToken(jwtRefreshToken);
		redisTemplate.opsForValue().set(CachePrefix.REFRESH_TOKEN.name() + UserEnums.USER.name() + jwtRefreshToken
				,"1", 15, TimeUnit.DAYS);

		return token;
	}
}
```

#### 所需技术

##### ①spring security  —— 加密及判断密码是否相同

```XML
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.jasypt</groupId>
    <artifactId>jasypt-spring-boot-starter</artifactId>
</dependency>
```

数据存入[数据库](https://so.csdn.net/so/search?q=数据库&spm=1001.2101.3001.7020)库时

```JAVA
public static void main(String[] args) {
System.out.println(new BCryptPasswordEncoder().encode("123456"));
}
```

当需要登录时，可以用下面这行代码进行解密

```java
LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<User>()
    .eq(User::getUsername, username);
List<User> userList = this.list(queryWrapper);

User user = userList.get(0);
if (ObjectUtils.isEmpty(user)) {
    return ResponseResult.accountNotFoundError();
}

//用的security的密码类
if (!new BCryptPasswordEncoder().matches(password, user.getPassword())) {
    return ResponseResult.accountError();
}
```

用于代表访问者账号的有关信息:  [Spring Security核心组件之安全上下文](https://blog.csdn.net/qq_41071876/article/details/122290308)

##### ②JWT  —— 生成token

具体见:      <img src="%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240310212945690.png" alt="image-20240310212945690" style="zoom:67%;" />

依赖:

```xml
<!--   token加密 -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.12.3</version>
</dependency>
<!--   token加密结束 -->
```

参考: [JWT令牌生成和解析（库：jjwt 版本：0.12.3）](https://blog.csdn.net/qq_45137726/article/details/135885870)

##### ③Redis  —— 缓存

就是Redis缓存知识

```java
redisTemplate.opsForValue().set(CachePrefix.REFRESH_TOKEN.name() + UserEnums.USER.name() + "jwtRefreshToken", "1", 15, TimeUnit.DAYS);
```

### 测试结果

![image-20240313164345572](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240313164345572.png)

## 登录认证

![image-20240311172134694](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240311172134694.png)

###  导包

~~~xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
~~~

### security配置类

~~~java
package com.lfj.blog.config.security;

import com.lfj.blog.handler.security.CustomAccessDeniedHandler;
import com.lfj.blog.handler.security.UserAuthenticationFilter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

/**
 * @Author: LFJ
 * @Date: 2024-03-10 22:55
 * security配置类
 */
@Slf4j
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class UserSecurityConfig extends WebSecurityConfigurerAdapter {
	@Autowired
	private StringRedisTemplate redisTemplate;

	/**
	 * 忽略验权配置
	 */
	@Autowired
	private IgnoredUrlsProperties ignoredUrlsProperties;

	/**
	 * spring security 权限不足处理
	 */
	@Autowired
	private CustomAccessDeniedHandler customAccessDeniedHandler;
	@Autowired
	private AuthenticationEntryPoint customAuthenticationEntryPoint;

	@Override
	protected void configure(HttpSecurity http) throws Exception {

		ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry registry = http
				.authorizeRequests();
		//配置的url 不需要授权
		for (String url : ignoredUrlsProperties.getUrls()) {
			registry.antMatchers(url).permitAll();
		}
		registry
				.and()
				//禁止网页iframe
				.headers().frameOptions().disable()
				.and()
				.logout()
				.permitAll()
				.and()
				.authorizeRequests()
				//任何请求
				.anyRequest()
				//需要身份认证
				.authenticated()
				.and()
				//允许跨域
				.cors().and()
				//关闭跨站请求防护
				.csrf().disable()
				//前后端分离采用JWT 不需要session
				.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
				.and()
				//自定义权限拒绝处理类// 权限拦截器，提示用户没有当前权限
				.exceptionHandling().authenticationEntryPoint(customAuthenticationEntryPoint).accessDeniedHandler(customAccessDeniedHandler)
				.and()
				//添加JWT认证过滤器(自定义)
				.addFilter(new UserAuthenticationFilter(authenticationManager(), redisTemplate));
	}

}

~~~

### 忽略配置类

~~~java
package com.lfj.blog.config.security;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.util.ArrayList;
import java.util.List;

/**
 * @Author: LFJ
 * @Date: 2024-03-10 22:57
 */
@Configuration
@ConfigurationProperties(prefix = "ignored")
@Data
public class IgnoredUrlsProperties {
	private List<String> urls = new ArrayList<>();
}

~~~

使用:   在配置文件写不用进行token认证的请求路径

~~~yml
ignored:
  urls:
    - /pages/**
    - /pageData/**
    - /article/**
    - /goods/**
    - /members/**
    - /category/**
    - /common/**
~~~

### 认证过滤器

~~~java
package com.lfj.blog.utils.token;

/**
 * @Author: LFJ
 * @Date: 2024-03-09 15:24
 */
public class SecurityKey {
	public static final String USER_CONTEXT = "userContext";

	public static final String ACCESS_TOKEN = "accessToken";
}
~~~

![image-20240313164054236](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240313164054236.png)

实现

~~~java
package com.lfj.blog.handler.security;

import com.alibaba.fastjson2.JSON;
import com.baomidou.mybatisplus.core.toolkit.StringUtils;
import com.lfj.blog.common.cache.CachePrefix;
import com.lfj.blog.common.security.AuthUser;
import com.lfj.blog.common.security.UserEnums;
import com.lfj.blog.common.vo.ResponseResult;
import com.lfj.blog.utils.token.SecretKeyUtil;
import com.lfj.blog.utils.token.SecurityKey;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;
import com.lfj.blog.utils.ResponseUtil;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;


/**
 * @Author: LFJ
 * @Date: 2024-03-10 22:59
 *
 * 认证结果过滤器
 *
 */
@Slf4j
public class UserAuthenticationFilter extends BasicAuthenticationFilter {
	private StringRedisTemplate redisTemplate;

	/**
	 * 自定义构造器
	 *
	 * @param authenticationManager
	 */
	public UserAuthenticationFilter(AuthenticationManager authenticationManager
			, StringRedisTemplate redisTemplate) {
		super(authenticationManager);
		this.redisTemplate = redisTemplate;
	}

	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException, IOException {

		//从header中获取jwt
		String jwt = request.getHeader(SecurityKey.ACCESS_TOKEN);
		try {
			//如果请求头没有携带token 则return
			if (StringUtils.isBlank(jwt)) {
				chain.doFilter(request, response);
				return;
			}
			//获取用户信息，存入context
			UsernamePasswordAuthenticationToken authentication = getAuthentication(jwt, response);
			SecurityContextHolder.getContext().setAuthentication(authentication);
		} catch (Exception e) {
			log.error("BuyerAuthenticationFilter-> member authentication exception:", e);
		}
		chain.doFilter(request, response);
	}

	/**
	 * 解析用户
	 * 读取Token信息，创建UsernamePasswordAuthenticationToken对象
	 * @param jwt
	 * @param response
	 * @return
	 */
	private UsernamePasswordAuthenticationToken getAuthentication(String jwt, HttpServletResponse response) {

		try {
			Claims claims = Jwts.parser()
					.verifyWith(SecretKeyUtil.generalKey()) // 传递密钥
					.build()
					.parseSignedClaims(jwt)//传递jwt令牌参数
					.getPayload();  // 获取- Payload(有效载荷）
			//获取存储在claims中的用户信息
			String json = claims.get(SecurityKey.USER_CONTEXT).toString();
			AuthUser authUser = JSON.parseObject(json, AuthUser.class);

			//校验redis中是否有权限
			Boolean hasKey = redisTemplate.hasKey(CachePrefix.ACCESS_TOKEN.name() + UserEnums.USER.name() + jwt);
			if (hasKey != null && hasKey) {
				//构造返回信息
				List<GrantedAuthority> auths = new ArrayList<>();
				auths.add(new SimpleGrantedAuthority("ROLE_" + authUser.getRole().name()));
				UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(authUser.getUsername(), null, auths);
				authentication.setDetails(authUser);
				return authentication;
			}
			return null;
		} catch (ExpiredJwtException e) {
			log.debug("user analysis exception:", e);
		} catch (Exception e) {
			log.error("user analysis exception:", e);
		}
		return null;
	}
}
~~~

###  认证失败的返回权限不足

#### CustomAccessDeniedHandler

~~~java
package com.lfj.blog.handler.security;

import com.alibaba.fastjson2.JSONObject;
import com.lfj.blog.common.vo.ResponseResult;
import com.lfj.blog.utils.ResponseUtil;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * 如果用户处于登陆（authenticated）状态，会触发AccessDeniedHandler。
 * @Author: LFJ
 * @Date: 2024-03-10 23:13
 * 目的：当用户访问了不属于自己权限的访问路径的时候，返回json格式的异常错误提示代码
 */
@Component("customAccessDeniedHandler")
public class CustomAccessDeniedHandler implements AccessDeniedHandler {
	@Override
	public void handle(HttpServletRequest httpServletRequest,
					   HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {
		ResponseUtil.output(httpServletResponse, ResponseResult.noPermission());
	}
}
~~~

#### CustomAuthenticationEntryPoint

```java
package com.lfj.blog.handler.security;

import com.alibaba.fastjson2.JSONObject;
import com.lfj.blog.common.vo.ResponseResult;
import com.lfj.blog.utils.ResponseUtil;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * 如果用户处于未登录（anonymous）状态，会先触发AuthenticationEntryPoint，如果没有配置，
 * @Author: LFJ
 * @Date: 2024-03-13 17:21
 */
@Component("customAuthenticationEntryPoint")
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {
	@Override
	public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException, IOException {
		ResponseUtil.output(response, ResponseResult.noPermission());
	}
}
```

### 工具类

**作用:  用于任何地方发起响应数据**

~~~java
package com.lfj.blog.utils;

import com.alibaba.fastjson2.JSON;
import com.lfj.blog.common.vo.ResponseResult;
import lombok.extern.slf4j.Slf4j;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @Author: LFJ
 * @Date: 2024-03-10 23:14
 * response 输出响应工具, 用于任何地方发起响应数据, 不需要PostMapping()等等
 * 实现了在任何地方方便地输出响应数据到HttpServletResponse中的功能。
 */
@Slf4j
public class ResponseUtil {

	static final String ENCODING = "UTF-8";
	static final String CONTENT_TYPE = "application/json;charset=UTF-8";

	/**
	 * 输出前端内容以及状态指定
	 *
	 * @param response
	 * @param status
	 * @param content
	 */
	public static void output(HttpServletResponse response, Integer status, String content) {
		ServletOutputStream servletOutputStream = null;
		try {
			response.setCharacterEncoding(ENCODING);
			response.setContentType(CONTENT_TYPE);
			response.setStatus(status);
			servletOutputStream = response.getOutputStream();
			servletOutputStream.write(content.getBytes());
		} catch (Exception e) {
			log.error("response output error: ", e);
		} finally {
			if (servletOutputStream != null) {
				try {
					servletOutputStream.flush();
					servletOutputStream.close();
				} catch (IOException e) {
					log.error("response output IO close error:", e);
				}
			}
		}
	}


	/**
	 * response 输出JSON
	 *
	 * @param response
	 * @param status    response 状态
	 * @param result
	 */
	public static void output(HttpServletResponse response, Integer status, ResponseResult result) {
		response.setStatus(status);
		output(response, result);
	}


	/**
	 * response 输出JSON
	 *
	 * @param response
	 * @param result
	 */
	public static void output(HttpServletResponse response, ResponseResult result) {
		ServletOutputStream servletOutputStream = null;
		try {
			response.setCharacterEncoding(ENCODING);
			response.setContentType(CONTENT_TYPE);
			servletOutputStream = response.getOutputStream();
//			System.out.println(result.getMessage());
			servletOutputStream.write(JSON.toJSONString(result).getBytes());
			log.info("Response output successful");
		} catch (Exception e) {
			log.error("response output error:", e);
		} finally {
			if (servletOutputStream != null) {
				try {
					servletOutputStream.flush();
					servletOutputStream.close();
				} catch (IOException e) {
					log.error("response output IO close error:", e);
				}
			}
		}
	}

}

~~~

### 测试结果

**情况1:  请求头没带token, 返回空**

![image-20240311170523945](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240311170523945.png)

**情况2:  请求头带有效token, 但是Redis无效了(删除Redis), 返回你没有访问权限**

![image-20240313174048531](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240313174048531.png)

**情况3:  请求头带有效token, 返回成功响应数据**

![image-20240311191415030](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240311191415030.png)

## Spring Security之安全上下文

这里安全上下文SecurityContext指的是当前执行线程使用的最少量的安全信息(其实就是用于代表访问者账号的有关信息)。

### 配置

```java
package com.lfj.blog.handler.security;

import com.lfj.blog.common.security.AuthUser;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolderStrategy;

/**
 * 用户上下文
 * @Author: LFJ
 * @Date: 2024-03-13 17:56
 */
public class UserContext {
	private static AuthenticationHandler authenticationHandler;

	public static void setHolder(AuthenticationHandler authenticationHandler) {
		UserContext.authenticationHandler = authenticationHandler;
	}


	public static AuthUser getCurrentUser() {
		return authenticationHandler.getAuthUser();
	}

}

```



```java
package com.lfj.blog.handler.security;

import com.lfj.blog.common.security.AuthUser;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

/**
 * 获取用户信息 处理
 * @Author: LFJ
 * @Date: 2024-03-13 17:59
 */
@Component
public class AuthenticationHandler {
	/**
	 * 获取当前用户信息
	 *
	 * @return
	 */
	public AuthUser getAuthUser() {
		//获取spring security 权限信息，如果token有权限，在这里就会得到内容
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		if (authentication == null) {
			return null;
		}
		Object object = authentication.getDetails();
		if (object instanceof AuthUser) {
			return (AuthUser) authentication.getDetails();
		}
		return null;
	}
}

```



```java
package com.lfj.blog.handler.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

/**
 * 给予用户上下文，初始化参数
 * @Author: LFJ
 * @Date: 2024-03-13 18:00
 */
@Component
public class UserContextInit implements ApplicationRunner {
	/**
	 * 用户信息holder，认证信息的获取者
	 */
	@Autowired
	private AuthenticationHandler authenticationHandler;

	/**
	 * 在项目加载时指定认证信息获取者
	 * 默认是由spring 安全上下文中获取
	 *
	 * @param args
	 * @throws Exception
	 */
	@Override
	public void run(ApplicationArguments args) {
		UserContext.setHolder(authenticationHandler);
	}
}

```

### 使用

```java
@Override
public ResponseResult<User> getUserInfo() {

    AuthUser currentUser = UserContext.getCurrentUser();   // 使用 Spring Security之安全上下文
    if (currentUser != null){
        String id = currentUser.getId();
        // mybatis查询
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<User>()
            .eq(User::getId,id);
        List<User> userList = this.list(queryWrapper);
        if (userList.get(0) == null){
            return null;
        }
        return ResponseResult.success(userList.get(0));
    }
   
    return ResponseResult.tokenError();
}
```

## 前端 登录功能

```tsx
//点击登录
const login = async () => {
  const userLogInfo = toRaw(logInfo);// 将一个由生成的响应式转化为对象普通对象
  // 发起请求
  const { data, error, loading, run } = useRequest(getSysLogin, {
    manual: true, // 手动触发请求
    devKey: "demo1", // 开发者密钥
    onSuccess: (data) => {
      //注意: 在手动触发的情况下, ts中使用data,error,....中的属性
      if (data.code === 400002) {
        alert("账号不存在");
      } else if (data.code === 400004) {
        alert("账户密码不匹配");
      } else if (data.code === 200000) {
        //前端接收到JWT后，将其存储在本地
        localStorage.setItem("accessToken", data.data.accessToken);
        localStorage.setItem("refreshToken", data.data.refreshToken);
        // 得到用户信息
        getInformation();
        router.replace("/index");
      }
    },
    onError: (error) => {
      alert(error);
    },
  });

  run(userLogInfo);
};


const getInformation = () => {
  const { data: responseData, run: infoRun } = useRequest(getUserInfo, {
    onSuccess: (responseData) => {
      if (responseData && responseData.data) {
        // console.table(responseData.data);
        const userAccount = window.encodeURIComponent(  // 加密保存
          JSON.stringify(responseData.data) //即使后端发送的数据已经是 JSON 格式，使用 JSON.stringify() 仍然是一个常见的做法，因为它可以确保数据被正确地序列化为 JSON 字符串。
        );
        // console.log(userAccount);
        // 保存到浏览器和pinia中
        localStorage.setItem("userInfo", userAccount);
        pinia.setUserInfo(userAccount);
      } else {
        console.error("未获取到有效的用户信息数据");
      }
    },
  });

  infoRun();
};
```

**导航**

pina  状态管理  相当于静态变量   通过 路由跳转来进行刷新页面 状态能保存。但是直接通过刷新，相当于重新部署，要保存状态只能通过浏览器（locatestorage等）

尽管 localStorage 是一个方便的浏览器存储解决方案，但在大多数情况下，对于应用的状态管理和数据管理，使用 Pinia 或 Vuex 更为合适。可以将需要持久化的数据存储在 localStorage 中，但最好将应用的状态和核心数据存储在状态管理库中，以获得更好的数据管理和状态管理能力

```tsx
// 在页面加载时从本地存储中获取用户信息并设置到 Pinia 中
const initializeUserInfo = () => {
  const storedUserInfo = localStorage.getItem('userInfo'); 
  
  if (storedUserInfo) {
     pinia.setUserInfo(storedUserInfo);       
}
};

// 页面加载时初始化用户信息
initializeUserInfo();
```

![image-20240313162246881](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240313162246881.png)





## 注册

### 核心实现

```java
@Service
public class SysRegisterServiceImpl implements SysRegisterService {

	@Autowired
	UserService userService;

	@Override
	public ResponseResult<String> register(RegisterInfo registerInfo) {
		String name = registerInfo.getUsername();
		// 如果用户名不存在, 则用户注册
		if (ObjectUtils.isEmpty(userService.selectAllByUsername(name))){
			User user = new User();
			user.setPassword(registerInfo.getPassword());
			user.setUsername(name);
			userService.insertSelective(user);
		}
		else {
			return ResponseResult.accountRegisteredError();
		}
		return ResponseResult.success("success");
	}
}

```

### 测试结果

#### 如果用户名不存在, 则用户注册

![image-20240314224327039](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240314224327039.png)

![image-20240314224307323](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240314224307323.png)



#### 如果用户名存在, 则返回用户名已被注册

![image-20240314224433418](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240314224433418.png)

## 刷新token

refreshToken就是用来在accessToken过期以后来重新获取accessToken的

#### 1、使用流程

1. 登录成功获得 refresh token 并持久化
2. 通过 refresh token 请求刷新得到 access token 并临时储存
3. 请求业务接口使用 access token
4. access token 过期或者快过期再次回到「 2 」
5. refresh token 也过期则生命周期结束，需重新登录

#### 2、使用场景

1. 如果是一个前后端分离的项目，使用springsecurity+jwt这种，前端用户在登录以后，后端返回给前端一个accessToken，如果没有refresh token，又因为因为安全原因accessToken过期时间会设置的比较短，在accessToken过期以后，用户将会被强制重新登录，影响用户体验
   而如果使用refresh Token，如果用户持续地访问这个网站，他们可以一直保持登录状态，而不需要定期重新登录
2. 如果是业务服务器之间的相互调用，那么此时只用一个Access Token即可，强制重新登录影响不大，只不过是如果使用 Refresh Token 在获取新的 Access Token 的时候比直接重新登录会方便一小丢丢

#### 3、从是否需要读取额外的状态来看

token 的过期时间一般会比 refeshToken 的过期时间短很多，保证 token 被盗取后无法持久的做坏事，通过 AccessToken 访问，只要通过签名校验合法即可通行，无需读取额外的状态来进一步确认是否撤销，当 AccessToken 过期以后再通过 RefreshToken 读取额外的状态（数据库 /缓存）确认是否继续签发

#### 4、从安全程度来看

1. access token 有效期短 被盗损失更小 安全性更高
   如果refresh token被盗了 想刷新access token的话 也需要提供过期的refresh token 盗取难度增加
2. 同时refresh token只有在第一次获取和刷新access token时才会在网络中传输，因此被盗的风险远小于access token 从而在一定程度上 更安全了一点

#### 代码

##### 前端代码修改

接口路径修改，改为sso访问:

api/index.js

~~~js
export async function handleRefreshToken(token:string){
    let url = import.meta.env.VITE_APP_BASE_API + '/login/refresh/' + token;
    return request<ResponseResult<TokenType>>(url, {
      method: 'get',
      needToken: false  //需要请求头携带token, 后端好进行认证

    })
}

/**
http://localhost:9000/login/refresh/eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyQ29udGV4dCI6IntcImlkXCI6XCIxXCIsXCJpc1N1cGVyXCI6ZmFsc2UsXCJsb25nVGVybVwiOmZhbHNlLFwibmlja05hbWVcIjpcImxmalwiLFwicm9sZVwiOjEsXCJ1c2VybmFtZVwiOlwibGZqXCJ9Iiwic3ViIjoibGZqIiwiZXhwIjoxNzEyMTU1OTYwfQ.YCr8kU7n6JEzyI1cLAyYD9kH88bpp0fZ-Gx77gwozvs
 
{
    "code": 200000,
    "data": {
        "accessToken": "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyQ29udGV4dCI6IntcImlkXCI6XCIxXCIsXCJpc1N1cGVyXCI6ZmFsc2UsXCJsb25nVGVybVwiOmZhbHNlLFwibmlja05hbWVcIjpcImxmalwiLFwicm9sZVwiOjEsXCJ1c2VybmFtZVwiOlwibGZqXCJ9Iiwic3ViIjoibGZqIiwiZXhwIjoxNzEwODYwMzUxfQ.DuOXtoIYOAuJX_Y9HByU4T8Z5wYn4BVL0-Nw6bkE_Tk",
        "refreshToken": "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyQ29udGV4dCI6IntcImlkXCI6XCIxXCIsXCJpc1N1cGVyXCI6ZmFsc2UsXCJsb25nVGVybVwiOmZhbHNlLFwibmlja05hbWVcIjpcImxmalwiLFwicm9sZVwiOjEsXCJ1c2VybmFtZVwiOlwibGZqXCJ9Iiwic3ViIjoibGZqIiwiZXhwIjoxNzEwODYwMzYyfQ.Vyxrr7yDeEmDr7kQlPmFYGvYQCuq_41QYFfIfOZwlL0"
    },
    "message": "响应成功"
}
*/
~~~

axios.ts封装

~~~js
import axios, { AxiosRequestConfig, AxiosResponse } from "axios";
import qs from "qs";
import { handleRefreshToken } from "/@/services/api";
import { useRouter } from "vue-router";

const router = useRouter();
// 导入配置的环境变量url
// import baseURL from "./base-url";

// axios.defaults.headers.post["Content-Type"] =
//   "application/json;charset=utf-8";
let isRefreshToken = 0;
const refreshToken = getTokenDebounce();
const axiosInstance = axios.create({
  timeout: 10000,
  // axios中请求配置有baseURL选项,表示请求URL公共部分,每个请求将会带该部分
  // baseURL: import.meta.env.VITE_API_URL,//配置了跨域这里不用写会冲突
});

// TODO 这里扩展里InternalAxiosRequestConfig类型
// 目的用接口类型进行typeScript的类型覆盖, config.xxxx是会有提示，不会报错的
interface InternalAxiosRequestConfig extends AxiosRequestConfig{  
  // 表示发起axios请求时,可以带的参数
  interceptors?: InternalAxiosRequestConfig
  headers?: any; // 可选属性
  needToken?: boolean;  // 需要token认证的接口携带这个
}

// 请求拦截
axiosInstance.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    // //TODO 这里写前端请求 headers 需要携带的东西
    // const isPutPost = config.method === "put" || config.method === "post";
    // const isJson = config.headers["Content-Type"] === "application/json";
    // const isFile = config.headers["Content-Type"] === "multipart/form-data";

    // if (isPutPost && isJson) {
    //   config.data = JSON.stringify(config.data);
    // }
    // if (isPutPost && !isFile && !isJson) {
    //   //前后端交互时,将对象序列化为url形式的数据，用&拼接
    //   config.data = qs.stringify(config.data, {
    //     arrayFormat: "repeat",
    //   });
    // }

    // 获取访问Token
    let accessToken = localStorage.getItem("accessToken");
    // let accessToken =  getAccessToken();
    let refreshToken = localStorage.getItem("refreshToken");

    // console.log("refreshToken:" + refreshToken);
    if (accessToken && config.needToken) {
      config.headers["accessToken"] = accessToken; // 前端发送请求的时候携带这个 token  
      // 解析当前token时间
      let jwtData = JSON.parse(
        decodeURIComponent(encodeURIComponent(window.atob(accessToken.split(".")[1])))//对 JWT 中的 payload 部分进行解码和编码操作
      );
      // 认证时间失效
      // if (jwtData.exp < Math.round(new Date().getTime() / 1000)) {
        refresh(config);
      // }
    }

    return config;
  },
  (error) => {
    // 当请求失败时做一些处理 抛出错误
    return Promise.reject(error);
  }
);

async function refresh (error) {
  const getTokenRes = await refreshToken();
  // console.log("3333:"+getTokenRes)
  if (getTokenRes === 'success') {
    // 刷新token
    if (isRefreshToken === 1) {
      error.response.config.headers.accessToken = localStorage.getItem(
        'accessToken'
      );
      return axiosInstance(error.response.config);
    } else {
      router.go(0);
    }
  } else {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    localStorage.removeItem('userAccount');
    // Modal.confirm({
    //   title: '请登录',
    //   content: '<p>请登录后执行此操作</p>',
    //   okText: '立即登录',
    //   cancelText: '继续浏览',
    //   onOk: () => {
    //     router.push({
    //       path: '/login',
    //       query: {
    //         // rePath: router.current.path,
    //         // query: JSON.stringify(router.history.current.query)
    //       }
    //     });
    //   },
    //   onCancel: () => {
    //     Modal.remove();
    //   }
    // });
  }
}


// 响应拦截
axiosInstance.interceptors.response.use(
  (response) => {
    //console.log("Response Data:", response.data); // 打印响应数据
    if (response?.status === 200) {
      return Promise.resolve(response);
    }
    if (response?.status === 403) {
      isRefreshToken++;

      if (isRefreshToken === 1) {
        // refresh(error)
        isRefreshToken = 0;
      }
    } else if (response?.status === 404) {
      // 避免刷新token时也提示报错信息
    } 
  },
  (error) => {
    if (error?.message?.includes?.("timeout")) {
      console.log("timeout");
    } else {
      console.log(error);
    }
    Promise.reject(error);
  }
);

// 定义一个泛型函数 request，用于发送 HTTP 请求
const request = <ResponseType = unknown>(
  url: string,
  // options?: AxiosRequestConfig<unknown>
  options?: InternalAxiosRequestConfig
): Promise<ResponseType> => {
  // 返回一个 Promise 对象，Promise 的泛型参数是 ResponseType，即期望的响应数据类型
  return new Promise((resolve, reject) => {
    // 使用 axiosInstance 发送 HTTP 请求
    axiosInstance({
      url,
      ...options, // 将传入的 options 合并到请求配置中
    })
      .then((res) => {
        // 请求成功时，将解析后的响应数据传递给 Promise 的 resolve 函数
        //res.data 得到响应数据
        //console.log(res.data);
        resolve(res.data as ResponseType);
      })
      .catch((err) => {
        // 请求失败时，将错误信息传递给 Promise 的 reject 函数
        reject(err);
      });
  });
};


// 防抖闭包来一波
function getTokenDebounce () {
  let lock = false;
  let success = false;
  return function () {
    if (!lock) {
      lock = true;
      let oldRefreshToken = localStorage.getItem('refreshToken');
      if (oldRefreshToken){
        // console.log(oldRefreshToken);
      handleRefreshToken(oldRefreshToken)
        .then(res => {
          console.log(res);
          
          if (res.code === 200000) {
            console.log(res.code);
            
            let { accessToken, refreshToken } = res.data;
            localStorage.setItem('accessToken', accessToken);
            localStorage.setItem('refreshToken', refreshToken);
            success = true;
            lock = false;
          } else {
            success = false;
            lock = false;
            // router.push('/login')
          }
        })
        .catch(err => {
          console.log(err);
          success = false;
          lock = false;
        });
      }
    }
    return new Promise(resolve => {
      // 一直看lock,直到请求失败或者成功
      const timer = setInterval(() => {
        if (!lock) {
          clearInterval(timer);
          if (success) {
            resolve('success');
          } else {
            resolve('fail');
          }
        }
      }, 500); // 轮询时间间隔
    });
  };
}


export { axiosInstance, request };

~~~

##### Controller代码

~~~java
	@GetMapping("/refresh/{refreshToken}")
	public ResponseResult<Object> refreshToken(@PathVariable String refreshToken) {
		return this.sysLoginService.refreshToken(refreshToken);
	}
~~~

#####  Service代码

~~~java
@Override
	public ResponseResult<Object> refreshToken(String refreshToken) {
		Claims claim = TokenUtils.parserToken(refreshToken);
		if (claim == null){
			return ResponseResult.tokenError();
		}
		AuthUser authUser = JSON.parseObject(claim.get(SecurityKey.USER_CONTEXT).toString(), AuthUser.class);

		String value = redisTemplate.opsForValue().get(CachePrefix.REFRESH_TOKEN.name() + UserEnums.USER.name() + refreshToken);
		if (StringUtils.isBlank(value)){
			return ResponseResult.tokenError();
		}
		Token token = new Token();
		String accessToken = TokenUtils.createToken(authUser.getUsername(), authUser, 7 * 24 * 60L);
		redisTemplate.opsForValue().set(CachePrefix.ACCESS_TOKEN.name() + UserEnums.USER.name() + accessToken, "true",7, TimeUnit.DAYS);	//放入redis当中

		String newRefreshToken = TokenUtils.createToken(authUser.getUsername(), authUser, 15 * 24 * 60L);
		redisTemplate.opsForValue().set(CachePrefix.REFRESH_TOKEN.name() + UserEnums.USER.name() + refreshToken, "true",15, TimeUnit.DAYS);

		token.setAccessToken(accessToken);
		token.setRefreshToken(newRefreshToken);
		return ResponseResult.success(token);
	}

~~~

TokenUtils:

~~~java
	public static Claims parserToken(String refreshToken) {
		try {
			Claims claims = Jwts.parser()
					.verifyWith(SecretKeyUtil.generalKeyByDecoders())
					.build()
					.parseSignedClaims(refreshToken)
					.getPayload();
			return claims;
		} catch (ExpiredJwtException | UnsupportedJwtException | MalformedJwtException | SignatureException | IllegalArgumentException e) {
			//token 过期 认证失败等
			return null;
		}
	}
~~~

# springboot+shiro+redis+jwt

实现多端登录：PC端和移动端同时在线（不同终端可同时在线）

[springboot+shiro+redis+jwt实现多端登录：PC端和移动端同时在线（不同终端可同时在线）

![image-20240313174526827](%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84.assets/image-20240313174526827.png)

# 总结

总结来说，用户登录和权限认证的流程可以简化为以下几个步骤：

1. 用户在前端页面输入用户名和密码，并点击登录按钮。
2. 前端发送POST请求到后端的登录接口，传递用户名和密码。
3. 后端验证用户名和密码的正确性，如果验证通过，JWT生成token
   + 然后把token放入redis当中，accessToken 过期短， refreshToken 过期长, 最后返回给前端。
4. 前端接收到token后，将其存储在本地
   + Token存到localStorage
   + 用户数据存通过window.encodeURIComponent( JSON.stringify(用户数据)) 加密保存到localStorage和pinia)。
5. 前端封装axios.ts 使每次请求都携带Token。
6. 前端通过Vue Router进行页面跳转，后端进行权限校验。在需要进行权限校验的页面组件中，检查本地存储中是否存在JWT，如果不存在，则跳转到登录页面。
7. 在每次向后端发送请求时，将token作为请求头的Authorization字段进行传递。
7. 后端在接收到请求时，解析token并进行权限校验，校验通过则返回相应的数据或页面。需要用户信息的数据要使用Spring Security之安全上下文得到访问者账号的有关信息, 再到对应的mysql查询数据